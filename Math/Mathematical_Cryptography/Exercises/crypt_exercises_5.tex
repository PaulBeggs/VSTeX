\newcommand{\indco}{\text{IndCo}}
\setcounter{chapter}{5}

\begin{exercise}
    {5.10}Encrypt each of the following Vigen\`ere plaintexts using the given keyword
    and the Vigen\`ere tableau (Table 5.1 in book).
    \begin{enumerate}
        \item Keyword: \texttt{hamlet}

              Plaintext: \texttt{To be, or not to be, that is the question.}
    \end{enumerate}
\end{exercise}

\sol{
    \begin{enumerate}
        \item Hamlet is made up of 6 letters, so we repeat the keyword to match the length of the plaintext:
              \[
                  \texttt{tobeor\quad |\quad nottobe\quad |\quad thatis\quad |\quad theque\quad |\quad stion}
              \]
              Then, find the row that starts with the key-letter. For instance, since \texttt{hamlet} starts with \texttt{h}, we go down to the \(8^{\text{th}}\) row in Table 5.1. Then, we go right until we reach the column of our plaintext. So, for \texttt{t}, that would be the \(20^{\text{th}}\) column.

              See the table below for the full encryption. Note that \(\mathcal{P}, \mathcal{K}\), and \(\mathcal{C}\) indicate the plaintext, keyword, and ciphertext, respectively:
              \begin{center}
                  \begin{tabular}[htbp]{c||c|c|c|c|c}
                      \(\mathcal{P}\) & \texttt{tobeor} & \texttt{nottobe} & \texttt{thatis} & \texttt{theque} & \texttt{stion}  \\
                      \(\mathcal{K}\) & \texttt{hamlet} & \texttt{hamlet}  & \texttt{hamlet} & \texttt{hamlet} & \texttt{hamlet} \\
                      \(\mathcal{C}\) & \texttt{aonpsk} & \texttt{uofesu}  & \texttt{lttlxb} & \texttt{zttpun} & \texttt{lsftsg} \\
                  \end{tabular}
              \end{center}
    \end{enumerate}
}



\begin{exercise}
    {5.11}Decrypt each of the following Vigen\`ere ciphertexts using the given keyword and the Vigen\`ere tableau (Table 5.1 in book).
    \begin{enumerate}
        \item Keyword: \texttt{condiment}
              \vspace*{-0.8em}
              \begin{tabbing}
                  Ciphertext: \= \texttt{r s g h z \ b m c x t \ d v f s q \ h n i g q \ x r n b m} \\
                  \> \texttt{p d n s q \ s m b t r \ k u}
              \end{tabbing}
    \end{enumerate}
\end{exercise}
\sol{
    \begin{enumerate}
        \item Reversing the method from \hyperref[exerc:5.10]{Exercise 5.10}, we have: \\
              \begin{center}
                  \begin{tabular}[htbp]{c||c|c|c|c|c}
                      \(\mathcal{C}\) & \texttt{rsghzbmcx} & \texttt{tdvfsqhni} & \texttt{gpxrnbmpd} & \texttt{nsqsmbtrk} & \texttt{u} \\
                      \(\mathcal{K}\) & \texttt{condiment} & \texttt{condiment} & \texttt{condiment} & \texttt{condiment} & \texttt{c} \\
                      \(\mathcal{P}\) & \texttt{peterpipe} & \texttt{rpickedap} & \texttt{eckofpick} & \texttt{ledpepper} & \texttt{s} \\
                  \end{tabular} \\
              \end{center}

              we find the decrypted ciphertext to be:
              \begin{center}
                  \texttt{peter piper picked a peck of pickled peppers}
              \end{center}
    \end{enumerate}
}

\begin{exercise}
    {5.13}Let
    \begin{align*}
        s & = \text{``I am the very model of a modern major general.''}     \\
        t & = \text{``I have information vegetable, animal, and mineral.''}
    \end{align*}
    \begin{enumerate}
        \item Make frequency tables for \(s\) and \(t\).
        \item Compute \(\indco(s)\) and \(\indco(t)\).
    \end{enumerate}
\end{exercise}

\begin{table}[htbp]
    \centering
    \setlength{\tabcolsep}{4pt}
    \begin{tabular}{@{}ccccccccccccccccccccccccccc@{}}
        \toprule
                   & A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q & R & S & T & U & V & W & X & Y & Z \\ \midrule
        Freq \(s\) & 4 & 0 & 0 & 2 & 6 & 1 & 1 & 1 & 1 & 1 & 0 & 2 & 4 & 2 & 4 & 0 & 0 & 4 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 \\ \midrule
        Freq \(t\) & 8 & 1 & 0 & 1 & 4 & 1 & 1 & 1 & 5 & 0 & 0 & 3 & 3 & 5 & 2 & 0 & 0 & 2 & 0 & 2 & 0 & 2 & 0 & 0 & 0 & 0 \\
        \bottomrule
    \end{tabular}
    \caption{Frequency Distribution for \(s\) and \(t\) }\label{tab:5.1}
\end{table}


\sol{
    \begin{enumerate}
        \item The frequency table for \(s\) and \(t\) is shown in \hyperref[tab:5.1]{Table 5.1}.
        \item We find the index of coincidence for \(s\) to be:
              \begin{align*}
                  \indco(s) & = \frac{1}{n(n - 1)}\sum_{i = 0}^{25} F_{i}(F_{i} - 1) \\ &= \frac{1}{36(35)}(4 \cdot 3 + 2 \cdot 1 + 6 \cdot 5 + \cdots + 0 \cdot 0) \\
                            & = \frac{84}{1260}                                      \\
                            & \approx 0.0667.
              \end{align*}
              Then, for \(t\), we have:
              \begin{align*}
                  \indco(t) & = \frac{1}{n(n - 1)}\sum_{i = 0}^{25} F_{i}(F_{i} - 1) \\ &= \frac{1}{41(40)}(8 \cdot 7 + 4 \cdot 3 + \cdots + 0 \cdot 0) \\
                            & = \frac{128}{1640}                                     \\
                            & \approx 0.0780.
              \end{align*}
    \end{enumerate}

}


\begin{exercise}
    {5.15}
    \begin{enumerate}
        \item One of the following two strings was encrypted using a simple substitution cipher, while the other is a random string of letters. the index of coincidence of each string and use the results to guess which is which.
              \begin{align*}
                  s_{1} & = \texttt{RCZBWBFHSLPSCPILHBGZJTGBIBJGLYIJIBFHCQQFZBYFP}, \\
                  s_{2} & = \texttt{KHQWGIZMGKPOYRKHUITDUXLXCWZOTWPAHFOHMGFEVUEJJ}.
              \end{align*}
    \end{enumerate}
\end{exercise}

\begin{table}[htbp]
    \centering
    \setlength{\tabcolsep}{4pt}
    \begin{tabular}{@{}ccccccccccccccccccccccccccc@{}}
        \toprule
                       & A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q & R & S & T & U & V & W & X & Y & Z \\ \midrule
        Freq \(s_{1}\) & 0 & 7 & 3 & 0 & 0 & 4 & 3 & 3 & 4 & 3 & 0 & 3 & 0 & 0 & 0 & 3 & 2 & 1 & 2 & 1 & 0 & 0 & 1 & 0 & 2 & 3 \\ \midrule
        Freq \(s_{2}\) & 1 & 0 & 1 & 1 & 2 & 2 & 3 & 4 & 2 & 2 & 3 & 1 & 2 & 0 & 3 & 2 & 1 & 1 & 0 & 2 & 3 & 1 & 3 & 2 & 1 & 2 \\
        \bottomrule
    \end{tabular}
    \caption{Frequency Distribution for \(s_{1}\) and \(s_{2}\) }\label{tab:5.2}
\end{table}

\sol{
    \begin{enumerate}
        \item See the table below for the frequency distribution of \(s_{1}\) and \(s_{2}\) in \hyperref[tab:5.2]{Table 5.2}. We find the index of coincidence for \(s_{1}\) to be:
              \begin{align*}
                  \indco(s_{1}) & = \frac{114}{45(44)} \\
                                & \approx 0.0576.
              \end{align*}
              Then, for \(s_{2}\), we have:
              \begin{align*}
                  \indco(s_{2}) & = \frac{60}{45(44)} \\
                                & \approx 0.0303.
              \end{align*}

              Since the index of coincidence for \(s_{1}\) is higher than that of \(s_{2}\), we can guess that \(s_{1}\) was encrypted using a simple substitution cipher.
    \end{enumerate}
}




\begin{exercise}
    {5.17}We applied a Kasiski test to the Vigen\`ere ciphertext listed below and found that the key length is probably 5. Use Excel to find the plaintext and the key.
    \[\begin{array}{l}
            \texttt{togmg \ gbymk \ kcqiv \ dmlxk \ kbyif \ vcuek \ cuuis \ vvxqs \ pwwej \ koqgg} \\
            \texttt{phumt \ whlsf \ yovww \ knhhm \ rcqfq \ vvhkw \ psued \ ugrsf \ ctwij \ khvfa} \\
            \texttt{thkef \ fwptj \ ggviv \ cgdra \ pgwvm \ osqxg \ hkdvt \ whuev \ kcwyj \ psgsn} \\
            \texttt{gfwsl \ jsfse \ ooqhw \ tofsh \ aciin \ gfbif \ gabgj \ adwsy \ topml \ ecqzw} \\
            \texttt{asgvs \ fwrqs \ fsfvq \ rhdrs \ nmvmk \ cbhrv \ kblxk \ gzi}                   \\
        \end{array}\]
\end{exercise}


\sol{
    From the problem, I knew the key size was 5. Thus, I used the IndCo keysize 5 sheet. This is my order of operations:
    \begin{enumerate}[label=\arabic*.]
        \item Change the Ciphertext: Capitalize letters and remove spaces.
        \item Paste this into A1.
        \item Confirm the IndCo value is appropriate (\(\indco=0.064\), so it is).
        \item Copy the concatenated string from C122 into first the first Excel sheet we did.
        \item Find the lowest \(\chi^{2}\) value, so I know what value to subtract 26 by.
        \item Go to \href{https://rot13.com/}{rot13} and paste the string in, then rotate it by 26 minus the value we found in the previous step.
        \item Record this string in the Excel sheet.
        \item Repeat step 4-7 for the rest of the concatenated strings.
    \end{enumerate}
    We end up with 5 decrypted strings. Now, we need to read them from top to bottom. To concatenate the strings, I used the following python code in \hyperref[lst:5.1]{Listing 5.1}. Once I ran the code, I got the following plaintext:

    \begin{center}
        Radio, envisioned by its inventor as a great humanitarian contribution, was seized upon by the generals soon after its birth and impressed as an instrument of war. But radio turned over to the commander a copy of every enemy cryptogram it conveyed. Radio made cryptanalysis an end in itself.\footnotemark[1]
    \end{center}

    To find the key, I used the following python code in \hyperref[lst:5.2]{Listing 5.2}. The key was found to be \texttt{CODES}.
    \footnotetext{\(\phantom{0}^{1}\)A Google search with the decrypted words led me to the plaintext in proper grammatical form without capitalization and proper spacing.}
}
\newpage
\begin{lstlisting}[language=Python, caption=Python Code to Concatenate Strings, label={lst:5.1}]
    cipher_text = [
        'REIBITATNINUWIPTNSAIRDEANMFUINEHMRYEEYRCYDDPLAIE',
        'ANOYNOGHIATTAZOHESFTTISSSEWTOEREAAORMPAOEIETYNNL',
        'DVNIVRRUTNRISENEROTSHMSATNARTDTCNCFYYTMNDOCASEIF',
        'IIETEAEMACIOSDBGAOEBAPENRTRAUOOODOEECOIVRMRNINT',
        'OSDSNSAAROBNEUYELNRINRDIUOBDRVTMEPVNRGTEAAYASDS',
    ]
    
    # Number of rows and columns
    num_rows = len(cipher_text)
    num_cols = min(len(row) for row in cipher_text)
    
    # Read the text column by column
    decoded_text = ''
    for col in range(num_cols):
        for row in range(num_rows):
            decoded_text += cipher_text[row][col]
    
    # Print the result
    print('Decoded text (column-by-column):')
    print(decoded_text)
\end{lstlisting}
\vspace*{-0.5cm}
\begin{lstlisting}[language=Python, caption=Python Code to Find Key, label={lst:5.2}]
    # Plaintext and Ciphertext have been omitted because they would not fit in the page.
    plaintext = '...'
    ciphertext = '...'
    
    # Known key length
    key_length = 5
    
    # Helper function to convert letters to alphabetical index (A=0, B=1, ..., Z=25)
    def letter_to_index(letter):
        return ord(letter) - ord('A')
    
    # Helper function to convert index back to a letter
    def index_to_letter(index):
        return chr(index + ord('A'))
    
    # Calculate the key by determining the shift for each character in the key
    key = []
    for i in range(key_length):
        # Compute the shift for each position in the key
        shift = (letter_to_index(ciphertext[i]) - letter_to_index(plaintext[i])) % 26
        key.append(index_to_letter(shift))
    
    # Join the key characters into a string
    key_word = ''.join(key)
    print('Derived key:', key_word)
    
\end{lstlisting}